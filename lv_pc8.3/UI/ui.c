// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.2
// LVGL version: 8.3.11
// Project name: SquareLine_Project

#include "ui.h"

// SCREEN: ui_Screen1
void ui_Screen1_screen_init(void);
lv_obj_t * ui_Screen1;
lv_obj_t * ui_allcontainer;
lv_obj_t * ui_topsingle3;
lv_obj_t * ui_safesinglecontainer;
lv_obj_t * ui_safetybete;
lv_obj_t * ui_motor;
lv_obj_t * ui_hydraulic;
lv_obj_t * ui_oilbox;
lv_obj_t * ui_leftlight;
lv_obj_t * ui_rightlight;
lv_obj_t * ui_taiyalow;
lv_obj_t * ui_taiyahigh;
lv_obj_t * ui_lightcontainer;
void ui_event_closelight(lv_event_t * e);
lv_obj_t * ui_closelight;
void ui_event_farlight(lv_event_t * e);
lv_obj_t * ui_farlight;
lv_obj_t * ui_timepanel;
lv_obj_t * ui_timelabel;
lv_obj_t * ui_yibiaopanpng;
void ui_event_fadonji(lv_event_t * e);
lv_obj_t * ui_fadonji;
lv_obj_t * ui_bottomsingle;
lv_obj_t * ui_topsingle1;
lv_obj_t * ui_topsingle2;
lv_obj_t * ui_speedpoint;
lv_obj_t * ui_oilpoint;
lv_obj_t * ui_powerpoint;
lv_obj_t * ui_licheng;
lv_obj_t * ui_lichengnum;
lv_obj_t * ui_wendu;
lv_obj_t * ui_wendunum;
void ui_event_sportmodechange(lv_event_t * e);
lv_obj_t * ui_sportmodechange;
lv_obj_t * ui_oilwendu;
lv_obj_t * ui_oilwendunum;


// SCREEN: ui_Screen2
void ui_Screen2_screen_init(void);
lv_obj_t * ui_Screen2;
lv_obj_t * ui_luntai;
void ui_event_youqianfang(lv_event_t * e);
lv_obj_t * ui_youqianfang;
void ui_event_zuoqianfang(lv_event_t * e);
lv_obj_t * ui_zuoqianfang;
void ui_event_zuohoufang(lv_event_t * e);
lv_obj_t * ui_zuohoufang;
void ui_event_youhoufang(lv_event_t * e);
lv_obj_t * ui_youhoufang;
void ui_event_leidamodechange(lv_event_t * e);
lv_obj_t * ui_leidamodechange;
lv_obj_t * ui_car;
lv_obj_t * ui_leida;
void ui_event_youshangld(lv_event_t * e);
lv_obj_t * ui_youshangld;
void ui_event_youxiald(lv_event_t * e);
lv_obj_t * ui_youxiald;
void ui_event_zuoxiald(lv_event_t * e);
lv_obj_t * ui_zuoxiald;
void ui_event_zuoshangld(lv_event_t * e);
lv_obj_t * ui_zuoshangld;
lv_obj_t * ui____initial_actions0;
const lv_img_dsc_t * ui_imgset_group_[1] = {&ui_img_group_14_png};
const lv_img_dsc_t * ui_imgset_rectangle_[1] = {&ui_img_rectangle_1_png};
const lv_img_dsc_t * ui_imgset_1405107096[4] = {&ui_img_624413955, &ui_img_457315224, &ui_img_1961050311, &ui_img_525674082};
const lv_img_dsc_t * ui_imgset_1405351560[3] = {&ui_img_960091386, &ui_img_960096759, &ui_img_960084724};
const lv_img_dsc_t * ui_imgset_926454100[1] = {&ui_img_414159209};
const lv_img_dsc_t * ui_imgset_250055599[3] = {&ui_img_184318935, &ui_img_2115575519, &ui_img_1033847363};

///////////////////// TEST LVGL SETTINGS ////////////////////
#if LV_COLOR_DEPTH != 32
    #error "LV_COLOR_DEPTH should be 32bit to match SquareLine Studio's settings"
#endif
#if LV_COLOR_16_SWAP !=0
    #error "LV_COLOR_16_SWAP should be 0 to match SquareLine Studio's settings"
#endif

///////////////////// ANIMATIONS ////////////////////
void oilpointanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_image_angle);
    lv_anim_set_values(&PropertyAnimation_0, 0, -1000);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_image_angle);
    lv_anim_start(&PropertyAnimation_0);

}
void speedanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 2000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_image_angle);
    lv_anim_set_values(&PropertyAnimation_0, 0, 2300);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_image_angle);
    lv_anim_start(&PropertyAnimation_0);

}
void poweranim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 2000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_image_angle);
    lv_anim_set_values(&PropertyAnimation_0, 0, 1500);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_image_angle);
    lv_anim_start(&PropertyAnimation_0);

}
void oilboxanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, LV_ANIM_REPEAT_INFINITE);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void motoranim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 1);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void safetybeteanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 1);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void hydraulicanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 1);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void rightlightanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 1);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void leftlightanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 1);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void taiyahighlight_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 1);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void taiyalowlight_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 1);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}

///////////////////// FUNCTIONS ////////////////////
void ui_event_closelight(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_closelight, 255);
    }
}
void ui_event_farlight(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_farlight, 255);
    }
}
void ui_event_fadonji(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_fadonji, 255);
    }
}
void ui_event_sportmodechange(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_screen_change(&ui_Screen2, LV_SCR_LOAD_ANIM_FADE_ON, 500, 0, &ui_Screen2_screen_init);
    }
}
void ui_event_youqianfang(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_youqianfang, 255);
    }
}
void ui_event_zuoqianfang(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_zuoqianfang, 255);
    }
}
void ui_event_zuohoufang(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_zuohoufang, 255);
    }
}
void ui_event_youhoufang(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_youhoufang, 255);
    }
}
void ui_event_leidamodechange(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_screen_change(&ui_Screen1, LV_SCR_LOAD_ANIM_FADE_ON, 500, 0, &ui_Screen1_screen_init);
    }
}
void ui_event_youshangld(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_youshangld, 255);
    }
}
void ui_event_youxiald(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_youxiald, 255);
    }
}
void ui_event_zuoxiald(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_zuoxiald, 255);
    }
}
void ui_event_zuoshangld(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_zuoshangld, 255);
    }
}

// -------------------------- 全局状态与结构体定义 --------------------------
// 1. 系统总激活状态（fadonji激活后才能操作其他功能）
bool g_fadonji_active = false;

// 2. safesinglecontainer图片动画配置（仅声明，运行时初始化）
typedef struct {
    const char *name;       // 终端输入名
    lv_obj_t **obj_ptr;     // 指向LVGL对象的指针（避免直接用未初始化对象）
    void (*anim_func)(lv_obj_t *, int); // 动画函数
    bool running;           // 动画运行状态
} SafeImgAnim;

SafeImgAnim g_safe_imgs[] = {
    {"safetybete", &ui_safetybete, safetybeteanim_Animation, false},
    {"motor",      &ui_motor,      motoranim_Animation,      false},
    {"hydraulic",  &ui_hydraulic,  hydraulicanim_Animation,  false},
    {"oilbox",     &ui_oilbox,     oilboxanim_Animation,     false},
    {"leftlight",  &ui_leftlight,  leftlightanim_Animation,  false},
    {"rightlight", &ui_rightlight, rightlightanim_Animation, false},
    {"taiyalow",   &ui_taiyalow,   taiyalowlight_Animation,  false},
    {"taiyahigh",  &ui_taiyahigh,  taiyahighlight_Animation, false}
};
#define SAFE_IMG_CNT (sizeof(g_safe_imgs)/sizeof(SafeImgAnim))

// 3. lightcontainer图片状态配置（同理，用指针）
typedef struct {
    const char *name;   // 终端输入名
    lv_obj_t **obj_ptr; // 指向LVGL对象的指针
    bool active;        // 激活状态（255=激活，100=取消）
} LightImg;

LightImg g_light_imgs[] = {
    {"closelight", &ui_closelight, false},
    {"farlight",   &ui_farlight,   false}
};
#define LIGHT_IMG_CNT (sizeof(g_light_imgs)/sizeof(LightImg))

// 4. Point图片角度动画配置（同理）
typedef struct {
    const char *name;       // 终端输入名
    lv_obj_t **obj_ptr;     // 指向LVGL对象的指针
    int min_angle;          // 最小角度阈值
    int max_angle;          // 最大角度阈值
    int current_angle;      // 当前角度
    bool running;           // 动画运行状态
} PointImg;

PointImg g_point_imgs[] = {
    {"speedpoint",  &ui_speedpoint,  0,    2300, 0, false}, // 初始角度将在init中读取
    {"oilpoint",    &ui_oilpoint,  -1000,  -0,    0, false},
    {"powerpoint",  &ui_powerpoint, -800, 1500, 0, false}
};
#define POINT_IMG_CNT (sizeof(g_point_imgs)/sizeof(PointImg))

// 5. 面板标签配置（同理）
typedef struct {
    const char *name;   // 终端输入名
    lv_obj_t **label_ptr;// 指向标签对象的指针
} PanelLabel;

PanelLabel g_panel_labels[] = {
    {"lichengnum",  &ui_lichengnum},
    {"wendunum",    &ui_wendunum},
    {"oilwendunum", &ui_oilwendunum}
};
#define PANEL_LABEL_CNT (sizeof(g_panel_labels)/sizeof(PanelLabel))

// 6. Screen2图片状态配置（同理）
typedef struct {
    const char *name;   // 终端输入名
    lv_obj_t **obj_ptr; // 指向LVGL对象的指针
    bool active;        // 激活状态（255=激活，初始0/10=取消）
} Screen2Img;

Screen2Img g_screen2_imgs[] = {
    {"youqianfang",  &ui_youqianfang,  false},
    {"zuoqianfang",  &ui_zuoqianfang,  false},
    {"zuohoufang",   &ui_zuohoufang,   false},
    {"youhoufang",   &ui_youhoufang,   false},
    {"youshangld",   &ui_youshangld,   false},
    {"youxiald",     &ui_youxiald,     false},
    {"zuoxiald",     &ui_zuoxiald,     false},
    {"zuoshangld",   &ui_zuoshangld,   false}
};
#define SCREEN2_IMG_CNT (sizeof(g_screen2_imgs)/sizeof(Screen2Img))

// 命令类型与消息结构体（不变）
typedef enum {
    CMD_FADONJI,        // 激活/取消fadonji
    CMD_SAFE_IMG,       // 控制safesinglecontainer动画
    CMD_LIGHT_IMG,      // 控制lightcontainer状态
    CMD_POINT_IMG,      // 控制point角度动画
    CMD_PANEL_LABEL,    // 设置面板标签值
    CMD_SPORT_MODE,     // 跳转Screen2
    CMD_LEIDA_MODE,     // 跳转Screen1
    CMD_SCREEN2_IMG     // 控制Screen2图片状态
} CmdType;

typedef struct {
    CmdType type;
    union {
        int idx; // 数组索引（SAFE/LIGHT/SCREEN2_IMG）
        struct {
            int idx;
            int target_angle;
            bool stop;
        } point;
        struct {
            int idx;
            char value[64];
        } panel;
    } data;
} CmdMsg;

// -------------------------- 核心功能函数 --------------------------
// 1. 更新时间标签（1秒刷新一次，格式：YYYY-MM-DD HH:MM:SS）
void update_time_label(lv_timer_t *timer) {
    (void)timer;
    time_t now = time(NULL);
    struct tm *local_tm = localtime(&now);
    if (!local_tm) return;
    char time_buf[32];
    strftime(time_buf, sizeof(time_buf), "%Y-%m-%d %H:%M:%S", local_tm);
    lv_label_set_text(ui_timelabel, time_buf);
}

// 新增动画执行回调函数（适配LVGL 8的回调类型）
static void anim_exec_angle(lv_anim_t *a, int32_t value) {
    PointImg *p = (PointImg *)lv_anim_get_user_data(a);
    if (p && p->obj_ptr && *p->obj_ptr) {
        lv_img_set_angle(*p->obj_ptr, value);
    }
}

// 角度动画完成回调
void point_anim_ready_cb(lv_anim_t *a) {
    PointImg *p = (PointImg *)lv_anim_get_user_data(a);
    if (p && p->obj_ptr && *p->obj_ptr) {
        p->current_angle = lv_img_get_angle(*p->obj_ptr);  // 从对象获取当前角度
        p->running = false;
        printf("[动画] %s 角度调整完成，当前角度：%d\n", p->name, p->current_angle);
    }
}

// 处理命令的函数（修正参数类型和结构体访问）
void process_cmd(void *arg) {
    CmdMsg *msg = (CmdMsg *)arg;
    if (!msg) return;

    // 验证系统激活状态（仅fadonji命令无需激活）
    if (msg->type != CMD_FADONJI && !g_fadonji_active) {
        printf("[提示] 请先输入\"fadonji\"激活系统！\n");
        lv_mem_free(msg);
        return;
    }

    switch (msg->type) {
        // 1. 处理fadonji激活/取消
        case CMD_FADONJI:
            g_fadonji_active = !g_fadonji_active;
            if (ui_fadonji) {
                lv_obj_set_style_opa(ui_fadonji, g_fadonji_active ? 255 : 100, LV_PART_MAIN);
            }
            printf("[状态] fadonji %s\n", g_fadonji_active ? "已激活" : "已取消");
            break;

        // 2. 处理safesinglecontainer图片动画（修正：精准删除动画）
        case CMD_SAFE_IMG: {
            SafeImgAnim *img = &g_safe_imgs[msg->data.idx];
            // 空指针检查
            if (!img->obj_ptr || !*img->obj_ptr) {
                printf("[错误] %s 对象未初始化或为空！\n", img->name);
                lv_mem_free(msg);
                return;
            }

            img->running = !img->running;
            if (img->running) {
                // 启动闪烁动画
                img->anim_func(*img->obj_ptr, 0);
                printf("[动画] %s 已启动\n", img->name);
            } else {
                // 精准删除SquareLine生成的透明度动画（关键修正）
                lv_anim_del(*img->obj_ptr, _ui_anim_callback_set_opacity);
                lv_obj_set_style_opa(*img->obj_ptr, 100, LV_PART_MAIN);
                img->running = false;  // 强制重置状态
                printf("[动画] %s 已停止\n", img->name);
            }
            break;
        }

        // 3. 处理lightcontainer图片状态
        case CMD_LIGHT_IMG: {
            LightImg *img = &g_light_imgs[msg->data.idx];
            if (!img->obj_ptr || !*img->obj_ptr) {
                printf("[错误] %s 对象未初始化或为空！\n", img->name);
                lv_mem_free(msg);
                return;
            }

            img->active = !img->active;
            lv_obj_set_style_opa(*img->obj_ptr, img->active ? 255 : 100, LV_PART_MAIN);
            printf("[状态] %s %s\n", img->name, img->active ? "已激活" : "已取消");
            break;
        }

        // 4. 处理point图片角度动画（修正：空指针检查+动画逻辑）
        case CMD_POINT_IMG: {
            PointImg *img = &g_point_imgs[msg->data.point.idx];
            // 双重空指针检查（核心修正，解决段错误）
            if (!img->obj_ptr || !*img->obj_ptr) {
                printf("[错误] %s 对象未初始化或为空！\n", img->name);
                lv_mem_free(msg);
                return;
            }

            if (msg->data.point.stop) {
                // 停止动画
                if (img->running) {
                    lv_anim_del(*img->obj_ptr, anim_exec_angle);
                    img->running = false;
                    img->current_angle = lv_img_get_angle(*img->obj_ptr);
                    printf("[动画] %s 已停止，当前角度：%d\n", img->name, img->current_angle);
                } else {
                    printf("[提示] %s 动画未运行\n", img->name);
                }
            } else {
                // 计算目标角度（限制在阈值内）
                int target = msg->data.point.target_angle;
                target = LV_MAX(target, img->min_angle);
                target = LV_MIN(target, img->max_angle);
                if (target == img->current_angle) {
                    printf("[提示] %s 当前角度已为 %d\n", img->name, target);
                    lv_mem_free(msg);
                    return;
                }

                // 启动角度调整动画
                if (img->running) lv_anim_del(*img->obj_ptr, anim_exec_angle);
                
                lv_anim_t anim;
                lv_anim_init(&anim);
                lv_anim_set_time(&anim, 2000);  // 动画时长2秒
                lv_anim_set_custom_exec_cb(&anim, anim_exec_angle);
                lv_anim_set_values(&anim, img->current_angle, target);
                lv_anim_set_path_cb(&anim, lv_anim_path_linear);
                lv_anim_set_user_data(&anim, img);  // 传递PointImg结构体
                lv_anim_set_ready_cb(&anim, (lv_anim_ready_cb_t)point_anim_ready_cb);
                lv_anim_start(&anim);
                
                img->running = true;
                printf("[动画] %s 开始调整角度至：%d（阈值：%d~%d）\n", 
                       img->name, target, img->min_angle, img->max_angle);
            }
            break;
        }

        // 5. 处理面板标签值设置（修正：oilwendu标签显示）
        case CMD_PANEL_LABEL: {
            PanelLabel *label = &g_panel_labels[msg->data.panel.idx];
            if (!label->label_ptr || !*label->label_ptr) {
                printf("[错误] %s 标签对象未初始化或为空！\n", label->name);
                lv_mem_free(msg);
                return;
            }

            // 强制设置标签透明度（解决父对象opa=0的问题）
            lv_label_set_text(*label->label_ptr, msg->data.panel.value);
            lv_obj_set_style_opa(*label->label_ptr, 255, LV_PART_MAIN);
            // 可选：修复父对象透明度（若需要）
            if (label->label_ptr == &ui_oilwendunum && ui_oilwendu) {
                lv_obj_set_style_opa(ui_oilwendu, 255, LV_PART_MAIN);
            }
            printf("[显示] %s 已设置为：%s\n", label->name, msg->data.panel.value);
            break;
        }

        // 6. 处理屏幕跳转
        case CMD_SPORT_MODE:
            _ui_screen_change(&ui_Screen2, LV_SCR_LOAD_ANIM_FADE_ON, 500, 0, &ui_Screen2_screen_init);
            printf("[跳转] 已切换至 Screen2\n");
            break;

        case CMD_LEIDA_MODE:
            _ui_screen_change(&ui_Screen1, LV_SCR_LOAD_ANIM_FADE_ON, 500, 0, &ui_Screen1_screen_init);
            printf("[跳转] 已切换至 Screen1\n");
            break;

        // 7. 处理Screen2图片状态
        case CMD_SCREEN2_IMG: {
            Screen2Img *img = &g_screen2_imgs[msg->data.idx];
            if (!img->obj_ptr || !*img->obj_ptr) {
                printf("[错误] %s 对象未初始化或为空！\n", img->name);
                lv_mem_free(msg);
                return;
            }

            img->active = !img->active;
            // 恢复初始透明度（zuohoufang初始10，其他0）
            uint8_t inactive_opa = (strcmp(img->name, "zuohoufang") == 0) ? 10 : 0;
            lv_obj_set_style_opa(*img->obj_ptr, img->active ? 255 : inactive_opa, LV_PART_MAIN);
            printf("[状态] %s %s\n", img->name, img->active ? "已激活" : "已取消");
            break;
        }

        default:
            printf("[错误] 未知命令！\n");
            break;
    }
    lv_mem_free(msg);  // 释放命令内存
}

// 输入线程函数（修正：删除未使用变量）
void *input_thread(void *arg) {
    (void)arg;
    char input_buf[128];
    printf("==================== 仪表盘控制终端 ====================\n");
    printf("操作说明：\n");
    printf("1. 输入\"fadonji\"激活/取消系统（所有操作需先激活）\n");
    printf("2. 动画控制：输入safesinglecontainer图片名（如\"safetybete\"）启动/停止\n");
    printf("3. 灯光控制：输入lightcontainer图片名（如\"closelight\"）激活/取消\n");
    printf("4. 指针调整：输入\"point名 角度\"（如\"speedpoint 1500\"），输入名停止\n");
    printf("5. 数值显示：输入\"面板名 值\"（如\"lichengnum 500km\"、\"oilwendunum 85℃\"）\n");
    printf("6. 屏幕跳转：\"sportmodechange\"→Screen2，\"leidamodechange\"→Screen1\n");
    printf("7. 雷达控制：输入Screen2图片名（如\"youqianfang\"）激活/取消\n");
    printf("========================================================\n");
    
    while (1) {
        printf("\n请输入命令：");
        if (fgets(input_buf, sizeof(input_buf), stdin) == NULL) continue;
        input_buf[strcspn(input_buf, "\n")] = '\0'; // 去除换行符
        if (strlen(input_buf) == 0) continue;

        // 拆分命令与参数
        char *cmd = strtok(input_buf, " ");
        char *param = strtok(NULL, " ");

        // 分配命令消息（LVGL内存分配，确保线程安全）
        CmdMsg *msg = (CmdMsg *)lv_mem_alloc(sizeof(CmdMsg));
        if (!msg) {
            printf("[错误] 内存分配失败！\n");
            continue;
        }
        memset(msg, 0, sizeof(CmdMsg));

        // 解析命令
        if (strcmp(cmd, "fadonji") == 0) {
            msg->type = CMD_FADONJI;
        } else if (strcmp(cmd, "sportmodechange") == 0) {
            msg->type = CMD_SPORT_MODE;
        } else if (strcmp(cmd, "leidamodechange") == 0) {
            msg->type = CMD_LEIDA_MODE;
        } else {
            // 匹配safesinglecontainer图片命令
            int i;
            bool found = false;
            for (i = 0; i < SAFE_IMG_CNT; i++) {
                if (strcmp(cmd, g_safe_imgs[i].name) == 0) {
                    msg->type = CMD_SAFE_IMG;
                    msg->data.idx = i;
                    found = true;
                    break;
                }
            }
            if (found) goto send_cmd;

            // 匹配lightcontainer图片命令
            for (i = 0; i < LIGHT_IMG_CNT; i++) {
                if (strcmp(cmd, g_light_imgs[i].name) == 0) {
                    msg->type = CMD_LIGHT_IMG;
                    msg->data.idx = i;
                    found = true;
                    break;
                }
            }
            if (found) goto send_cmd;

            // 匹配Screen2图片命令
            for (i = 0; i < SCREEN2_IMG_CNT; i++) {
                if (strcmp(cmd, g_screen2_imgs[i].name) == 0) {
                    msg->type = CMD_SCREEN2_IMG;
                    msg->data.idx = i;
                    found = true;
                    break;
                }
            }
            if (found) goto send_cmd;

            // 匹配面板标签命令（需参数）
            for (i = 0; i < PANEL_LABEL_CNT; i++) {
                if (strcmp(cmd, g_panel_labels[i].name) == 0) {
                    if (!param) {
                        printf("[错误] %s 需要参数（如\"%s 123km\"）\n", cmd, cmd);
                        lv_mem_free(msg);
                        found = true;
                        break;
                    }
                    msg->type = CMD_PANEL_LABEL;
                    msg->data.panel.idx = i;
                    strncpy(msg->data.panel.value, param, sizeof(msg->data.panel.value)-1);
                    found = true;
                    break;
                }
            }
            if (found) goto send_cmd;

            // 匹配Point图片命令（可选参数）
            for (i = 0; i < POINT_IMG_CNT; i++) {
                if (strcmp(cmd, g_point_imgs[i].name) == 0) {
                    msg->type = CMD_POINT_IMG;
                    msg->data.point.idx = i;
                    if (!param) {
                        msg->data.point.stop = true; // 无参数=停止动画
                    } else {
                        // 解析角度参数
                        char *endptr;
                        int target = strtol(param, &endptr, 10);
                        if (*endptr != '\0') {
                            printf("[错误] %s 参数必须为整数（如\"%s 1500\"）\n", cmd, cmd);
                            lv_mem_free(msg);
                            found = true;
                            break;
                        }
                        msg->data.point.stop = false;
                        msg->data.point.target_angle = target;
                    }
                    found = true;
                    break;
                }
            }
            if (found) goto send_cmd;

            // 未知命令
            printf("[错误] 未知命令：%s\n", cmd);
            lv_mem_free(msg);
            continue;
        }

    send_cmd:
        // 发送命令到主线程（线程安全）
        lv_async_call(process_cmd, msg);
    }
    return NULL;
}

// 初始化全局数组（在ui_init()后调用，确保LVGL对象已创建）
void init_global_arrays(void) {
    // 初始化Point图片的当前角度（从对象读取实际值，解决初始角度错误）
    for (int i = 0; i < POINT_IMG_CNT; i++) {
        PointImg *p = &g_point_imgs[i];
        if (!p->obj_ptr) {
            printf("[警告] %s 的obj_ptr未赋值！\n", p->name);
            continue;
        }
        if (!*p->obj_ptr) {
            printf("[警告] %s 对象未创建！\n", p->name);
            continue;
        }
        p->current_angle = lv_img_get_angle(*p->obj_ptr);
        printf("[初始化] %s 初始角度: %d（阈值：%d~%d）\n", 
               p->name, p->current_angle, p->min_angle, p->max_angle);
    }

    // 初始化fadonji初始状态（透明度100=未激活）
    if (ui_fadonji) {
        lv_obj_set_style_opa(ui_fadonji, 100, LV_PART_MAIN);
        printf("[初始化] fadonji 初始状态：未激活\n");
    }
}

// ------------------------------------------------------------------------

///////////////////// SCREENS ////////////////////

void ui_init(void)
{
    LV_EVENT_GET_COMP_CHILD = lv_event_register_id();

    lv_disp_t * dispp = lv_disp_get_default();
    lv_theme_t * theme = lv_theme_default_init(dispp, lv_palette_main(LV_PALETTE_BLUE), lv_palette_main(LV_PALETTE_RED),
                                               false, LV_FONT_DEFAULT);
    lv_disp_set_theme(dispp, theme);
    ui_Screen1_screen_init();
    ui_Screen2_screen_init();
    ui____initial_actions0 = lv_obj_create(NULL);
    lv_disp_load_scr(ui_Screen1);

    // 初始化全局数组（必须在UI创建后调用）
    init_global_arrays();

    // 创建时间更新定时器（1秒刷新）
    lv_timer_create(update_time_label, 1000, NULL);

    // 创建终端输入线程
    pthread_t tid;
    if (pthread_create(&tid, NULL, input_thread, NULL) != 0) {
        printf("[错误] 输入线程创建失败！\n");
        return;
    }
    pthread_detach(tid); // 线程分离，无需join
}