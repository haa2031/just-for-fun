// This file was generated by SquareLine Studio
// SquareLine Studio version: SquareLine Studio 1.4.2
// LVGL version: 8.3.11
// Project name: SquareLine_Project

#include "ui.h"
#include "ui_helpers.h"

// 全局命令队列和互斥锁
Queue cmd_queue;
pthread_mutex_t cmd_mutex;

///////////////////// VARIABLES ////////////////////
void oilpointanim_Animation(lv_obj_t * TargetObject, int delay);
void speedanim_Animation(lv_obj_t * TargetObject, int delay);
void poweranim_Animation(lv_obj_t * TargetObject, int delay);
void oilboxanim_Animation(lv_obj_t * TargetObject, int delay);
void motoranim_Animation(lv_obj_t * TargetObject, int delay);
void safetybeteanim_Animation(lv_obj_t * TargetObject, int delay);
void hydraulicanim_Animation(lv_obj_t * TargetObject, int delay);
void rightlightanim_Animation(lv_obj_t * TargetObject, int delay);
void leftlightanim_Animation(lv_obj_t * TargetObject, int delay);
void taiyahighlight_Animation(lv_obj_t * TargetObject, int delay);
void taiyalowlight_Animation(lv_obj_t * TargetObject, int delay);


// SCREEN: ui_Screen1
void ui_Screen1_screen_init(void);
lv_obj_t * ui_Screen1;
lv_obj_t * ui_allcontainer;
lv_obj_t * ui_topsingle3;
lv_obj_t * ui_safesinglecontainer;
lv_obj_t * ui_safetybete;
lv_obj_t * ui_motor;
lv_obj_t * ui_hydraulic;
lv_obj_t * ui_oilbox;
lv_obj_t * ui_leftlight;
lv_obj_t * ui_rightlight;
lv_obj_t * ui_taiyalow;
lv_obj_t * ui_taiyahigh;
lv_obj_t * ui_lightcontainer;
void ui_event_closelight(lv_event_t * e);
lv_obj_t * ui_closelight;
void ui_event_farlight(lv_event_t * e);
lv_obj_t * ui_farlight;
lv_obj_t * ui_timepanel;
lv_obj_t * ui_timelabel;
lv_obj_t * ui_yibiaopanpng;
lv_obj_t * ui_bottomsingle1;
lv_obj_t * ui_bottomsingle2;
lv_obj_t * ui_topsingle1;
lv_obj_t * ui_topsingle2;
lv_obj_t * ui_speedpoint;
lv_obj_t * ui_oilpoint;
lv_obj_t * ui_powerpoint;
lv_obj_t * ui_licheng;
lv_obj_t * ui_lichengnum;
lv_obj_t * ui_wendu;
lv_obj_t * ui_wendunum;
void ui_event_sportmodechange(lv_event_t * e);
lv_obj_t * ui_sportmodechange;


// SCREEN: ui_Screen2
void ui_Screen2_screen_init(void);
lv_obj_t * ui_Screen2;
lv_obj_t * ui_leida;
void ui_event_youqianfang(lv_event_t * e);
lv_obj_t * ui_youqianfang;
void ui_event_zuoqianfang(lv_event_t * e);
lv_obj_t * ui_zuoqianfang;
void ui_event_zuohoufang(lv_event_t * e);
lv_obj_t * ui_zuohoufang;
void ui_event_youhoufang(lv_event_t * e);
lv_obj_t * ui_youhoufang;
lv_obj_t * ui_car;
void ui_event_leidamodechange(lv_event_t * e);
lv_obj_t * ui_leidamodechange;
lv_obj_t * ui____initial_actions0;
const lv_img_dsc_t * ui_imgset_rectangle_[1] = {&ui_img_rectangle_1_png};
const lv_img_dsc_t * ui_imgset_1405107096[4] = {&ui_img_624413955, &ui_img_457315224, &ui_img_1961050311, &ui_img_525674082};
const lv_img_dsc_t * ui_imgset_1405351560[3] = {&ui_img_960091386, &ui_img_960096759, &ui_img_960084724};
const lv_img_dsc_t * ui_imgset_926454100[1] = {&ui_img_414159209};
const lv_img_dsc_t * ui_imgset_250055599[3] = {&ui_img_184318935, &ui_img_2115575519, &ui_img_1033847363};
const lv_img_dsc_t * ui_imgset_group_[1] = {&ui_img_group_14_png};

///////////////////// TEST LVGL SETTINGS ////////////////////
#if LV_COLOR_DEPTH != 32
    #error "LV_COLOR_DEPTH should be 32bit to match SquareLine Studio's settings"
#endif
#if LV_COLOR_16_SWAP !=0
    #error "LV_COLOR_16_SWAP should be 0 to match SquareLine Studio's settings"
#endif

///////////////////// ANIMATIONS ////////////////////
void oilpointanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_image_angle);
    lv_anim_set_values(&PropertyAnimation_0, 0, -1000);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_image_angle);
    lv_anim_start(&PropertyAnimation_0);

}
void speedanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 2000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_image_angle);
    lv_anim_set_values(&PropertyAnimation_0, 0, 2300);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_image_angle);
    lv_anim_start(&PropertyAnimation_0);

}
void poweranim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 2000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_image_angle);
    lv_anim_set_values(&PropertyAnimation_0, 0, 1500);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_image_angle);
    lv_anim_start(&PropertyAnimation_0);

}
void oilboxanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, LV_ANIM_REPEAT_INFINITE);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void motoranim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, LV_ANIM_REPEAT_INFINITE);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void safetybeteanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, LV_ANIM_REPEAT_INFINITE);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void hydraulicanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, LV_ANIM_REPEAT_INFINITE);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void rightlightanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, LV_ANIM_REPEAT_INFINITE);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void leftlightanim_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, LV_ANIM_REPEAT_INFINITE);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void taiyahighlight_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, LV_ANIM_REPEAT_INFINITE);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}
void taiyalowlight_Animation(lv_obj_t * TargetObject, int delay)
{
    ui_anim_user_data_t * PropertyAnimation_0_user_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
    PropertyAnimation_0_user_data->target = TargetObject;
    PropertyAnimation_0_user_data->val = -1;
    lv_anim_t PropertyAnimation_0;
    lv_anim_init(&PropertyAnimation_0);
    lv_anim_set_time(&PropertyAnimation_0, 1000);
    lv_anim_set_user_data(&PropertyAnimation_0, PropertyAnimation_0_user_data);
    lv_anim_set_custom_exec_cb(&PropertyAnimation_0, _ui_anim_callback_set_opacity);
    lv_anim_set_values(&PropertyAnimation_0, 100, 255);
    lv_anim_set_path_cb(&PropertyAnimation_0, lv_anim_path_linear);
    lv_anim_set_delay(&PropertyAnimation_0, delay + 0);
    lv_anim_set_deleted_cb(&PropertyAnimation_0, _ui_anim_callback_free_user_data);
    lv_anim_set_playback_time(&PropertyAnimation_0, 0);
    lv_anim_set_playback_delay(&PropertyAnimation_0, 0);
    lv_anim_set_repeat_count(&PropertyAnimation_0, LV_ANIM_REPEAT_INFINITE);
    lv_anim_set_repeat_delay(&PropertyAnimation_0, 0);
    lv_anim_set_early_apply(&PropertyAnimation_0, false);
    lv_anim_set_get_value_cb(&PropertyAnimation_0, &_ui_anim_callback_get_opacity);
    lv_anim_start(&PropertyAnimation_0);

}

///////////////////// FUNCTIONS ////////////////////
void ui_event_closelight(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_closelight, 255);
    }
}
void ui_event_farlight(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_farlight, 255);
    }
}
void ui_event_sportmodechange(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_screen_change(&ui_Screen2, LV_SCR_LOAD_ANIM_FADE_ON, 500, 0, &ui_Screen2_screen_init);
    }
}
void ui_event_youqianfang(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_youqianfang, 255);
    }
}
void ui_event_zuoqianfang(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_zuoqianfang, 255);
    }
}
void ui_event_zuohoufang(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_zuohoufang, 255);
    }
}
void ui_event_youhoufang(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_opacity_set(ui_youhoufang, 255);
    }
}
void ui_event_leidamodechange(lv_event_t * e)
{
    lv_event_code_t event_code = lv_event_get_code(e);
    lv_obj_t * target = lv_event_get_target(e);
    if(event_code == LV_EVENT_CLICKED) {
        _ui_screen_change(&ui_Screen1, LV_SCR_LOAD_ANIM_FADE_ON, 500, 0, &ui_Screen1_screen_init);
    }
}

/************************* 队列操作实现 *************************/
void queue_init(Queue *q) {
    q->front = 0;
    q->rear = 0;
    q->count = 0;
}

bool queue_enqueue(Queue *q, CmdMsg msg) {
    if (q->count >= QUEUE_SIZE) return false;
    q->data[q->rear] = msg;
    q->rear = (q->rear + 1) % QUEUE_SIZE;
    q->count++;
    return true;
}

bool queue_dequeue(Queue *q, CmdMsg *msg) {
    if (q->count == 0) return false;
    *msg = q->data[q->front];
    q->front = (q->front + 1) % QUEUE_SIZE;
    q->count--;
    return true;
}

/************************* 时间更新函数 *************************/
void update_time(lv_timer_t *timer) {
    time_t now = time(NULL);
    struct tm *local_tm = localtime(&now);
    if (!local_tm) return;

    char time_buf[20];
    strftime(time_buf, sizeof(time_buf), "%H:%M:%S", local_tm); // 格式：HH:MM:SS
    lv_label_set_text(ui_timelabel, time_buf);
}

/************************* 命令处理函数 *************************/
void process_cmd_queue(lv_timer_t *timer) {
    CmdMsg msg;
    while (queue_dequeue(&cmd_queue, &msg)) {
        switch (msg.type) {
            /********** 需求1：安全容器控件动画（启停）**********/
            case CMD_SAFE_ANIM: {
                lv_obj_t *obj = NULL;
                // 映射控件名到实际对象
                if      (strcmp(msg.name, "safetybete") == 0) obj = ui_safetybete;
                else if (strcmp(msg.name, "motor")      == 0) obj = ui_motor;
                else if (strcmp(msg.name, "hydraulic")  == 0) obj = ui_hydraulic;
                else if (strcmp(msg.name, "oilbox")     == 0) obj = ui_oilbox;
                else if (strcmp(msg.name, "leftlight")  == 0) obj = ui_leftlight;
                else if (strcmp(msg.name, "rightlight") == 0) obj = ui_rightlight;
                else if (strcmp(msg.name, "taiyalow")   == 0) obj = ui_taiyalow;
                else if (strcmp(msg.name, "taiyahigh")  == 0) obj = ui_taiyahigh;
                if (!obj) break;

                // 读取/初始化控件状态（1=动画运行，0=停止）
                int *anim_running = (int *)lv_obj_get_user_data(obj);
                if (!anim_running) {
                    anim_running = lv_mem_alloc(sizeof(int));
                    *anim_running = 0;
                    lv_obj_set_user_data(obj, anim_running);
                }

                if (*anim_running == 0) { // 启动动画
                    if      (strcmp(msg.name, "safetybete") == 0) safetybeteanim_Animation(obj, 0);
                    else if (strcmp(msg.name, "motor")      == 0) motoranim_Animation(obj, 0);
                    else if (strcmp(msg.name, "hydraulic")  == 0) hydraulicanim_Animation(obj, 0);
                    else if (strcmp(msg.name, "oilbox")     == 0) oilboxanim_Animation(obj, 0);
                    else if (strcmp(msg.name, "leftlight")  == 0) leftlightanim_Animation(obj, 0);
                    else if (strcmp(msg.name, "rightlight") == 0) rightlightanim_Animation(obj, 0);
                    else if (strcmp(msg.name, "taiyalow")   == 0) taiyalowlight_Animation(obj, 0);
                    else if (strcmp(msg.name, "taiyahigh")  == 0) taiyahighlight_Animation(obj, 0);
                    *anim_running = 1;
                    printf("[INFO] %s 动画已启动\n", msg.name);
                } else { // 停止动画
                    lv_anim_del(obj, NULL); // 删除所有绑定动画
                    lv_obj_set_style_opa(obj, 100, LV_PART_MAIN); // 恢复初始透明度
                    *anim_running = 0;
                    printf("[INFO] %s 动画已停止\n", msg.name);
                }
                break;
            }

            /********** 需求2：灯光控件状态切换 **********/
            case CMD_LIGHT_TOGGLE: {
                lv_obj_t *obj = NULL;
                if (strcmp(msg.name, "closelight") == 0) obj = ui_closelight;
                else if (strcmp(msg.name, "farlight") == 0) obj = ui_farlight;
                if (!obj) break;

                // 读取/初始化状态（1=激活，0=未激活）
                int *activated = (int *)lv_obj_get_user_data(obj);
                if (!activated) {
                    activated = lv_mem_alloc(sizeof(int));
                    *activated = 0;
                    lv_obj_set_user_data(obj, activated);
                }

                if (*activated == 0) { // 激活（设为255透明度）
                    lv_obj_set_style_opa(obj, 255, LV_PART_MAIN);
                    *activated = 1;
                    printf("[INFO] %s 已激活\n", msg.name);
                } else { // 取消激活（恢复100透明度）
                    lv_obj_set_style_opa(obj, 100, LV_PART_MAIN);
                    *activated = 0;
                    printf("[INFO] %s 已取消激活\n", msg.name);
                }
                break;
            }

            /********** 需求3/6：屏幕切换 **********/
            case CMD_SCREEN_SPORT:
                _ui_screen_change(&ui_Screen2, LV_SCR_LOAD_ANIM_FADE_ON, 500, 0, &ui_Screen2_screen_init);
                printf("[INFO] 已切换到 雷达屏幕（Screen2）\n");
                break;
            case CMD_SCREEN_LEIDA:
                _ui_screen_change(&ui_Screen1, LV_SCR_LOAD_ANIM_FADE_ON, 500, 0, &ui_Screen1_screen_init);
                printf("[INFO] 已切换到 仪表盘屏幕（Screen1）\n");
                break;

            /********** 需求4：里程/温度标签更新 **********/
            case CMD_UPDATE_LABEL: {
                lv_obj_t *obj = NULL;
                if (strcmp(msg.name, "lichengnum") == 0) obj = ui_lichengnum;
                else if (strcmp(msg.name, "wendunum") == 0) obj = ui_wendunum;
                if (!obj) break;

                char buf[32];
                snprintf(buf, sizeof(buf), "%d", msg.value);
                lv_label_set_text(obj, buf);
                printf("[INFO] %s 已更新为：%d\n", msg.name, msg.value);
                break;
            }

            /********** 需求5：指针角度控制 **********/
            case CMD_POINT_ROTATE: {
                lv_obj_t *obj = NULL;
                if      (strcmp(msg.name, "speedpoint") == 0) obj = ui_speedpoint;
                else if (strcmp(msg.name, "oilpoint")   == 0) obj = ui_oilpoint;
                else if (strcmp(msg.name, "powerpoint") == 0) obj = ui_powerpoint;
                if (!obj) break;

                // 读取当前角度，创建动态角度动画
                int current_angle = lv_img_get_angle(obj);
                ui_anim_user_data_t *anim_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
                anim_data->target = obj;
                anim_data->val = -1;

                lv_anim_t a;
                lv_anim_init(&a);
                lv_anim_set_time(&a, 1000); // 1秒转动过渡
                lv_anim_set_user_data(&a, anim_data);
                lv_anim_set_custom_exec_cb(&a, _ui_anim_callback_set_image_angle);
                lv_anim_set_values(&a, current_angle, msg.value); // 从当前到目标角度
                lv_anim_set_path_cb(&a, lv_anim_path_linear);
                lv_anim_set_deleted_cb(&a, _ui_anim_callback_free_user_data);
                lv_anim_set_repeat_count(&a, 0); // 仅执行一次
                lv_anim_set_get_value_cb(&a, &_ui_anim_callback_get_image_angle);
                lv_anim_start(&a);

                printf("[INFO] %s 已转动到 %d°（原角度：%d°）\n", msg.name, msg.value, current_angle);
                break;
            }

            /********** 需求6：雷达容器动画 **********/
            case CMD_LEIDA_ANIM: {
                lv_obj_t *obj = NULL;
                if      (strcmp(msg.name, "youqianfang")  == 0) obj = ui_youqianfang;
                else if (strcmp(msg.name, "zuoqianfang")  == 0) obj = ui_zuoqianfang;
                else if (strcmp(msg.name, "zuohoufang")   == 0) obj = ui_zuohoufang;
                else if (strcmp(msg.name, "youhoufang")   == 0) obj = ui_youhoufang;
                if (!obj) break;

                // 读取/初始化状态（1=动画运行，0=停止）
                int *anim_running = (int *)lv_obj_get_user_data(obj);
                if (!anim_running) {
                    anim_running = lv_mem_alloc(sizeof(int));
                    *anim_running = 0;
                    lv_obj_set_user_data(obj, anim_running);
                }

                if (*anim_running == 0) { // 启动动画（10→255透明度循环）
                    ui_anim_user_data_t *anim_data = lv_mem_alloc(sizeof(ui_anim_user_data_t));
                    anim_data->target = obj;
                    anim_data->val = -1;

                    lv_anim_t a;
                    lv_anim_init(&a);
                    lv_anim_set_time(&a, 1000);
                    lv_anim_set_user_data(&a, anim_data);
                    lv_anim_set_custom_exec_cb(&a, _ui_anim_callback_set_opacity);
                    lv_anim_set_values(&a, 10, 255);
                    lv_anim_set_path_cb(&a, lv_anim_path_linear);
                    lv_anim_set_deleted_cb(&a, _ui_anim_callback_free_user_data);
                    lv_anim_set_repeat_count(&a, LV_ANIM_REPEAT_INFINITE);
                    lv_anim_set_get_value_cb(&a, &_ui_anim_callback_get_opacity);
                    lv_anim_start(&a);

                    *anim_running = 1;
                    printf("[INFO] 雷达 %s 动画已启动\n", msg.name);
                } else { // 停止动画
                    lv_anim_del(obj, NULL);
                    lv_obj_set_style_opa(obj, 10, LV_PART_MAIN); // 恢复初始透明度
                    *anim_running = 0;
                    printf("[INFO] 雷达 %s 动画已停止\n", msg.name);
                }
                break;
            }

            default:
                printf("[ERROR] 未知命令：%d\n", msg.type);
                break;
        }
    }
}

/************************* 终端输入线程 *************************/
void *terminal_input_thread(void *arg) {
    char input[64];
    printf("===================== LVGL 终端控制 =====================\n");
    printf("可用命令说明：\n");
    printf("1. 安全容器动画（启停）：safetybete/motor/hydraulic/oilbox/leftlight/rightlight/taiyalow/taiyahigh\n");
    printf("2. 灯光控制（激活/取消）：closelight/farlight\n");
    printf("3. 屏幕切换：sportmodechange（→雷达屏）、leidamodechange（→仪表盘）\n");
    printf("4. 标签更新：lichengnum <值>（里程）、wendunum <值>（温度）\n");
    printf("5. 指针控制：speedpoint <角度>、oilpoint <角度>、powerpoint <角度>\n");
    printf("6. 雷达动画（启停）：youqianfang/zuoqianfang/zuohoufang/youhoufang\n");
    printf("==========================================================\n");

    while (1) {
        printf("\n请输入命令：");
        if (fgets(input, sizeof(input), stdin) == NULL) continue;
        input[strcspn(input, "\n")] = '\0'; // 去除换行符
        if (strlen(input) == 0) continue;

        CmdMsg msg = {0};
        char *cmd = strtok(input, " ");      // 拆分命令（第一部分为控件名）
        char *val_str = strtok(NULL, " ");   // 拆分值（如角度/标签值）

        /********** 命令分类判断 **********/
        // 1. 安全容器动画（无值）
        const char *safe_objs[] = {"safetybete", "motor", "hydraulic", "oilbox", "leftlight", "rightlight", "taiyalow", "taiyahigh", NULL};
        for (int i=0; safe_objs[i]; i++) {
            if (strcmp(cmd, safe_objs[i]) == 0) {
                msg.type = CMD_SAFE_ANIM;
                strncpy(msg.name, cmd, sizeof(msg.name)-1);
                goto enqueue;
            }
        }

        // 2. 灯光控制（无值）
        if (strcmp(cmd, "closelight") == 0 || strcmp(cmd, "farlight") == 0) {
            msg.type = CMD_LIGHT_TOGGLE;
            strncpy(msg.name, cmd, sizeof(msg.name)-1);
            goto enqueue;
        }

        // 3. 屏幕切换（无值）
        if (strcmp(cmd, "sportmodechange") == 0) {
            msg.type = CMD_SCREEN_SPORT;
            goto enqueue;
        }
        if (strcmp(cmd, "leidamodechange") == 0) {
            msg.type = CMD_SCREEN_LEIDA;
            goto enqueue;
        }

        // 4. 雷达动画（无值）
        const char *leida_objs[] = {"youqianfang", "zuoqianfang", "zuohoufang", "youhoufang", NULL};
        for (int i=0; leida_objs[i]; i++) {
            if (strcmp(cmd, leida_objs[i]) == 0) {
                msg.type = CMD_LEIDA_ANIM;
                strncpy(msg.name, cmd, sizeof(msg.name)-1);
                goto enqueue;
            }
        }

        // 5. 指针控制（需值）
        const char *point_objs[] = {"speedpoint", "oilpoint", "powerpoint", NULL};
        for (int i=0; point_objs[i]; i++) {
            if (strcmp(cmd, point_objs[i]) == 0) {
                if (!val_str) {
                    printf("[ERROR] %s 需输入角度值（如：%s 900）\n", cmd, cmd);
                    goto next_cmd;
                }
                msg.type = CMD_POINT_ROTATE;
                strncpy(msg.name, cmd, sizeof(msg.name)-1);
                msg.value = atoi(val_str);
                goto enqueue;
            }
        }

        // 6. 标签更新（需值）
        const char *label_objs[] = {"lichengnum", "wendunum", NULL};
        for (int i=0; label_objs[i]; i++) {
            if (strcmp(cmd, label_objs[i]) == 0) {
                if (!val_str) {
                    printf("[ERROR] %s 需输入数值（如：%s 123）\n", cmd, cmd);
                    goto next_cmd;
                }
                msg.type = CMD_UPDATE_LABEL;
                strncpy(msg.name, cmd, sizeof(msg.name)-1);
                msg.value = atoi(val_str);
                goto enqueue;
            }
        }

        // 未知命令
        printf("[ERROR] 未知命令：%s\n", cmd);
        goto next_cmd;

        /********** 命令入队（加互斥锁） **********/
    enqueue:
        pthread_mutex_lock(&cmd_mutex);
        if (!queue_enqueue(&cmd_queue, msg)) {
            printf("[ERROR] 命令队列已满，无法添加命令\n");
        }
        pthread_mutex_unlock(&cmd_mutex);

    next_cmd:
        continue;
    }
    return NULL;
}

///////////////////// SCREENS ////////////////////

void ui_init(void)
{
    LV_EVENT_GET_COMP_CHILD = lv_event_register_id();

    lv_disp_t * dispp = lv_disp_get_default();
    lv_theme_t * theme = lv_theme_default_init(dispp, lv_palette_main(LV_PALETTE_BLUE), lv_palette_main(LV_PALETTE_RED),
                                               false, LV_FONT_DEFAULT);
    lv_disp_set_theme(dispp, theme);
    ui_Screen1_screen_init();
    ui_Screen2_screen_init();
    ui____initial_actions0 = lv_obj_create(NULL);
    lv_disp_load_scr(ui_Screen1);
}
